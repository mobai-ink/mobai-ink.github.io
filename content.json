{"posts":[{"title":"1.两数之和","text":"题目描述给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 10^4 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 题解方法一：暴力循环时空复杂度: O(n^2) O(1) 这个方法大家应该都已经司空见惯了吧，直接暴力两重for循环，十分暴力，直接去找target - nums[i]这个数字，找到直接返回即可。这题的数据是nums.length &lt; 10^4就算执行暴力循环也就是O(10^8)的时间复杂度，没有超时。 12345678910public int[] brustMethod(int[] nums,int target) { //直接循环 for(int i = 0; i &lt; nums.length; i ++) { for(int j = i +1; j &lt; nums.length; j ++) { if(nums[i] + nums[j] == target) { return new int[]{i,j}; } } }} 方法二：排序+双指针时空复杂度: O(nlogn) O(n) 本人想到的第二种方法是使用排序加双指针，用空间换时间嘛，具体思路就是先存所有元素和下标关系到map中。然后对数组进行排序，用左端点和右端点的指针向中间逼近，当左指针指向的元素小于target就让左指针右移动，反之则让右指针左移。最终会找到两个目标元素。 12345678910111213141516171819202122232425262728293031323334353637383940public int[] sortAndDualMethod(int[] nums,int target){ //构建下标和元素值之间的关系,这里我们value使用List列表是因为可能两个元素相等。 //题目已经告诉我们了只有一个答案，所以不会出现一个元素和另一个出现两次的元素中的一个元素作为答案的情况 Map&lt;Integer,List&lt;Integer&gt;&gt; map = new HashMap(); for(int i = 0; i &lt; nums.length; i ++) { //获取元素对应的下标列表 List&lt;Integer&gt; list = map.getOrDefault(nums[i],new ArrayList&lt;Integer&gt;()); //将下标插入列表中 list.add(i); //存回map中 map.put(nums[i],list); } //排序数组 Arrays.sort(nums); //双指针查找 int l = 0,r = nums.length - 1; int sum = nums[l] + nums[r]; while(sum != target) { if(sum &gt; target) { r --; } else if(sum &lt; target) { l ++; } sum = nums[l] + nums[r]; } //当找到结果的时候 //如果是两个相同元素 if(nums[l] == nums[r]) { int[] res = new int[2]; res[0] = map.get(nums[l]).get(0); res[1] = map.get(nums[l]).get(1); return res; } else { //两个元素不同 return new int[]{map.get(nums[l]).get(0),map.get(nums[r]).get(0)}; }} 方法三：哈希表时空复杂度：O(n) O(n) 这种方法自认为是最优秀的，时间复杂度和空间复杂度都取决于结果元素出现在数组中的位置，最坏为O(n),最好为O(2),是十分优秀的了 12345678910111213public int[] hashMethod(int[] nums,int target) { //创建hash表 Map&lt;Integer,Integer&gt; map = new HashMap(); //这里存入哈希表的时候是依照数组顺序，所以无需考虑重复元素的问题。 for(int i = 0; i &lt; nums.length; i ++) { if(map.containsKey(target - nums[i])) { return new int[]{i,map.get(target - nums[i])}; } //如果哈希表中不存在这个元素就加入当前元素到哈希表，并且继续遍历 map.put(nums[i],i); } return null;} 总结有人相爱，有人夜里开车看海，有人LeetCode第一题都做不出来。(狗头)，这道题目还是考察我们对于哈希表的应用。当然我们也可以使用暴力算法，也是可以通过这道题目的，我们可以逐步优化自己的方法，本人刚开始写的时候也是使用O(n^2)的复杂度，后面想到使用双指针加排序，优化到了O(nlogn)，最后使用哈希表优化到了O(n)，我们要经历自己去优化方法的过程，这个过程还是比较锻炼我们的编程思维的。","link":"/2023/12/18/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"142.环形链表","text":"问题描述给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 解题思路方法一:使用哈希表时空复杂度: O(n) O(n) 根据题目要求，我们可以将遍历过的节点存入哈希表中，然后让指针后移，判断当前节点是否在哈希表中出现过，如果出现过就代表找到了环的初始连接点,如果当遍历到了NULL节点，代表链表中没有出现环. 12345678910111213141516171819202122public ListNode HashMethod(ListNode head) { //首先判断链表是否只有一个元素，或者没有元素 if(head == null) return null; //创建HashSet Set&lt;ListNode&gt; set = new HashSet(); //再次遍历链表，判断是否在哈希表中出现 ListNode cur = head; while(cur != null) { //遍历链表存入节点 set.add(cur); //让指针指向下一个节点 cur = cur.next; //判断当前节点是否存在于哈希表中 if(set.contains(cur)) { return cur; } } //直接返回NULL return cur;} 方法二:快慢指针+数学时空复杂度: O(n) O(1) 根据题目所述，我们可以定义两个指针，一个快指针一个慢指针，让快指针一次向后移动两个节点，慢指针一次移动一个节点。 如图: 分析：快慢指针还未进入环内的时候共同走过的路程设为x，由于快指针一次移动两个节点，所以肯定是比慢指针先进入环中，并且肯定是在慢指针进入环内的第一圈，快指针就追上了慢指针。图示如下: 由于我们的快指针每次移动两个节点，所以相对于慢指针来说，快指针每次都向后移动一个节点，所以当慢指针移动一圈的时候快指针相对于慢指针已经移动了一圈，所以当慢指针最多移动一圈的时候快指针一定能够追上慢指针，这里如果不理解，我们可以将x想象的趋近于0，即整个链表就是一个环。 根据快慢指针移动的性质，我们可以得到如下等式： 所以我们可以知道，当两个指针相遇的时候，即链表有环的时候，x是等于z的 这是一个很重要的数量关系 x = z 我们可以当快慢指针相遇的时候定义一个指针，让这个指针和从链表头开始的指针以相同的速度移动，相遇时就是链表的环起始点 所以我们可以得到代码 123456789101112131415161718192021222324252627public ListNode dualPointMethod(ListNode head) { //判断链表是否没有元素 if(head == null) return null; ListNode fast = head; ListNode slow = head; //因为fast一次移动两个节点，所以这里要判断两个位置 while(fast != null &amp;&amp; fast.next != null) { //快指针移动两个节点，慢指针移动一个节点 fast = fast.next.next; slow = slow.next; //如果当快指针等于慢指针就开始另一个遍历 if(fast == slow) { ListNode p = fast; slow = head; //当这两个指针相遇的时候就直接返回 while(p != slow) { p = p.next; slow = slow.next; } //返回 return p; } } //当fast为空或者fast.next为空就返回null return null;} 总结这道题目主要考察了我们对于数量关系的理解程度，和对快慢指针的使用场景。 其实这道题目考察了两个问题 1.链表中是否有环 2.链表中的环在哪个位置 我们要层层深入，逐一击破。掌握了判断链表中是否有环的方法(快慢指针)，以后遇到此类判断环的题目就不会再迷糊了。","link":"/2023/12/10/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"title":"15.三数之和","text":"题目描述给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2： 123输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3： 123输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5 题目分析这题本人第一次做的时候想到使用哈希表存储nums[a] + nums[b]的值，以此简化从n^3降低到n^2，但是现实如此残酷，本题使用哈希表并不是最佳解决方案，会面临去重的麻烦问题，所以这题最佳的易懂的解决方案应该是使用双指针+去重的方法完成这道题目。 方法一：哈希表思路：根据公式 nums[a] + nums[b] = -nums[c] 我们可以先使用双层for循环遍历数组，然后存储他们的和，然后再遍历一次数组，寻找等于 -nums[c] 的列表，然后把列表添加到结果集，但是我们要注意去重，这里可以使用Set集合进行去重。 代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243public List&lt;List&lt;Integer&gt;&gt; hashMethod(int[] nums) { //定义结果集 Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); //我们先定义一个 map 用于存储 nums[i] + nums[j] 的值 Map&lt;Integer,List&lt;List&lt;Integer&gt;&gt;&gt; map = new HashMap(); //双重for遍历获取值 for(int i = 0; i &lt; nums.length; i ++) { for(int j = i + 1; j &lt; nums.length; j ++) { //获取指定值在map中存储的List List&lt;List&lt;Integer&gt;&gt; list = map.getOrDefault(nums[i] + nums[j],new ArrayList()); //这里将下标封装进List List&lt;Integer&gt; list1 = new ArrayList(Arrays.asList(i,j)); //这里存入的是下标，因为后面要去重 list.add(list1); //存入map中 map.put(nums[i] + nums[j],list); } } //根据公式我们查找map中是否存在-(nums[i]),如果存在就将map中对应的list加入结果集中 for(int i = 0; i &lt; nums.length; i ++) { Set&lt;List&lt;Integer&gt;&gt; list = map.get(-nums[i]); if(list == null) { continue; } for(List&lt;Integer&gt; l : list) { if(!l.contains(i)) { //一个元素不可能出现多次 List&lt;Integer&gt; l2 = new ArrayList(l); l2.add(i); //将下标转换为nums中的元素 l2 = l2.stream().map((e)-&gt;nums[e]).collect(Collectors.toList()); //排序后存入Set集合中 l2.sort(Integer::compareTo); res.add(l2); } } } //转换Set集合成List return res.stream().collect(Collectors.toList());} 上面这种方法是比较繁琐的.我们使用双指针来优化，可以将时间复杂度优化到O(n) 方法二:双指针+去重思路: 我们可以定义一个指针遍历数组，然后用 left 和 right 指针来实现总和的变化如果 sum &gt; 0,就让 right –，如果 sum &lt; 0 就让 left++，当然，数组首先必须是有序的。但是，在指针的去重上面，也有一些细节需要注意，比如 我们定义当 sum[i] == sum[i + 1] 就 continue 还是，当 nums[i] == nums[i - 1] 才 continue，这里，如果我们选择第一种方法，会导致出现一种情况，当三元组中有重复元素的时候可能会出现漏掉记录，例如 [0,0,0] 的时候会出现无法加入到结果集中。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;List&lt;Integer&gt;&gt; dualPoint(int[] nums) { //首先创建结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); //对数组进行排序 Arrays.sort(nums); //如果排序后的第一个元素都大于0，那么就不会存在三元组和为0,直接返回空列表 if(nums[0] &gt; 0) return new ArrayList(); //创建第一个指针 for(int i = 0; i &lt; nums.length; i ++) { //这里我们要注意去重方式 if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; //定义left和right指针 int left = i + 1, right = nums.length - 1; //当left小于right的时候 while(left &lt; right) { //判断大小 int sum = nums[i] + nums[left] + nums[right]; if(sum &gt; 0) { //如果sum&gt;0的话就让right-- right --; } else if(sum &lt; 0) { //如果sum &lt; 0就让left ++ left ++; } else { //当出现满足条件的三元组，就直接加入结果集中，这里和去重顺序不能颠倒，不然会出现遗漏 res.add(new ArrayList(Arrays.asList(nums[i],nums[left],nums[right]))); //去重 while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left ++; } while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right --; } //去重完后开始新的一轮循环 (注意：这里要在去重后再移动left和right指针，不然会导致出现漏掉有重复元素的三元组) left ++; right --; } } } return res;} 总结这道题目相比前面的两数之和，难度有所提升，主要是我们要想到使用双指针来优化三元组的查找。不然直接使用哈希表会出现难以操作去重行为，而且时间复杂度还是比较高的。这题就到这里了，欢迎各位交流指点。","link":"/2023/12/28/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"18.四数之和","text":"题目描述给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 解题思路方法一：哈希表思路：这里的哈希表方法和上一题的类似，使用双层for循环先记录两数之和的列表，然后再使用双层for循环遍历，得到总和为target的目标列表，但是我们要注意去重，这里去重使用排序+Set集合的方式 代码： 12345678910111213141516171819202122232425262728293031323334353637383940/**超时O(n^2)这种方法在极端的情况下时间复杂度会到达O(n^4)所以并不合适 */public List&lt;List&lt;Integer&gt;&gt; hashMethod(int[] nums, int target) { // 构造map存储两个数字的和 Map&lt;Integer, List&lt;List&lt;Integer&gt;&gt;&gt; map = new HashMap(); for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { List&lt;List&lt;Integer&gt;&gt; list = map.getOrDefault(nums[i] + nums[j], new ArrayList()); list.add(new ArrayList(Arrays.asList(i, j))); map.put(nums[i] + nums[j], list); } } // 遍历再次判断值 Set&lt;List&lt;Integer&gt;&gt; res = new HashSet(); for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { List&lt;List&lt;Integer&gt;&gt; list = map.get(target - nums[i] - nums[j]); if (list == null) continue; for (List&lt;Integer&gt; l : list) { if (l.contains(i) || l.contains(j)) { continue; } List&lt;Integer&gt; l2 = new ArrayList(l); l2.add(i); l2.add(j); // 将l2转换成nums中的值 l2 = l2.stream().map((e) -&gt; nums[e]).collect(Collectors.toList()); l2.sort(Integer::compareTo); res.add(l2); } } } return res.stream().collect(Collectors.toList());} 方法二：双指针 + 二层去重 + 二层剪枝思路：我们可以借鉴上一题三数之和的方法，首先对数组进行排序，在最外层加一层指针，然后就能实现同样的效果，但是我们要考虑剪枝的时候，nums[0] 为负数的情况，所以我们在第二层剪枝的时候要把第一个指针和第二个指针当做一个整体。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public List&lt;List&lt;Integer&gt;&gt; dualPoint(int[] nums,int target) { //首先定义结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); //对数组进行排序 Arrays.sort(nums); //定义第一层指针 for(int i = 0; i &lt; nums.length; i ++) { //对第一层进行剪枝(当第一个指针都比target大，且所指元素大于0，代表后面如何计算都不可能等于target) if(nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) break; //对第一层进行去重(这使用nums[i] == nums[i - 1]是因为，我们要防止四元组中出现相同元素的情况漏掉统计) if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; //第二层指针 for(int j = i + 1; j &lt; nums.length; j ++) { //对第二层进行剪枝(这里把第一个指针和第二个作为整体) int entirety = nums[i] + nums[j]; if(entirety &gt; 0 &amp;&amp; entirety &gt; target) break; //对第二层进行去重(这里逻辑和第一层类似) if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; //定义左右指针 int left = j + 1,right = nums.length - 1; while(left &lt; right) { //判断大小移动左右指针 int sum = nums[i] + nums[j] + nums[left] + nums[right]; if(sum &gt; target) { right --; } else if(sum &lt; target) { left ++; } else { //当相等的时候直接加入结果集中，这里要注意顺序，去重应该在后面 res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); //去重 while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left ++; } while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right --; } //继续下一轮循环 left ++; right --; } } } } return res; }","link":"/2023/12/29/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"202.快乐数","text":"题目描述​ 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 1234567输入：n = 19输出：true解释：1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 示例 2： 12输入：n = 2输出：false 提示： 1 &lt;= n &lt;= 231 - 1 题解方法一：哈希表时空复杂度: O(243⋅3+logn+loglogn+logloglogn)… = O(log⁡n) O(logn) 这里的时空复杂度分析有些复杂，这里贴出官方的分析，大家可以参考[202.快乐数](202. 快乐数 - 力扣（LeetCode）) 这题根据题意可以直接进行模拟，然后将出现过的数存入Set集合中，在模拟过程中如果出现了在Set集合中存在的数字，则可以判断不是快乐数，当n等于1的时候就代表为快乐数字,这题时间复杂度笔者不会分析(泪目)。 1234567891011121314151617181920212223public boolean hashMethod(int n) { //创建集合存储出现过的元素 Set&lt;Integer&gt; set = new HashSet(); //当n不等于1的时候 while(n != 1) { //加入当前数字进入集合中 set.add(n); //创建变量统计总和 int sum = 0; while(n != 0) { sum += Math.pow((n % 10),2); n /= 10; } //判断当前数字是否在集合中出现过 if(set.contains(sum)) { return false; } //改变n n = sum; } //返回true return true;} 方法二：快慢指针时空复杂度: O(logn) O(1) 这里我们可以参考判圈的算法，虽然我们这里是对数字的处理，但是我们也可以类比到链表结构的前后节点，如果我们使用了判圈算法，可以省去存储遍历过的节点的Set集合的空间。具体思想就是创建一个快指针，一个慢指针，快指针一次移动两个单位，慢指针一次移动一个单位，这样子如果当有环出现的时候，快指针在环内就能追上慢指针了。 代码: 12345678910111213141516171819202122public boolean isHappy(int n) { //定义快慢指针 int slow = n; int fast = getNext(n); //当快指针不为1并且快慢指针不相等的时候继续循环 while(fast != 1 &amp;&amp; slow != fast){ slow = getNext(slow); fast = getNext(getNext(fast)); } //判断快指针是否等于1，即是否为快乐数，或者两个指针在环中相遇了 return fast == 1;}public int getNext(int n) { //定义求和变量 int sum = 0; while(n != 0) { sum += Math.pow((n % 10),2); n /= 10; } return sum; } 总结这道题目考察了我们，模拟，选用合适的数据结构存储数据的能力，这里我们合适使用Set集合存储，因为，Set中查找元素只需要O(1)的时间复杂度，而链式结构需要O(n)。方法二的快慢指针适用于查找存在环形结构的题目。好了，本题的就说到这里！","link":"/2023/12/16/202.%E5%BF%AB%E4%B9%90%E6%95%B0/"},{"title":"242.有效的字母异位词","text":"题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 提示: 1 &lt;= s.length, t.length &lt;= 5 * 104 s 和 t 仅包含小写字母 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 题解方法一:排序时空复杂度: O(nlogn) O(n) 可以直接对两个异位词进行sort排序，因为是按照字母的ASCII码来排序的，所以我们直接排序后的异位词一定是相等的。 代码: 1234567891011121314public boolean sortMethod(String s,String t) { //如果两个字符串长度不相等直接返回false if(s.length() != t.length()) { return false; } //将String字符串转换成char数组 char[] chars1 = s.toCharArray(); char[] chars2 = t.toCharArray(); //直接进行排序 Arrays.sort(chars1); Arrays.sort(chars2); //直接判断是否相等 return Arrays.equals(chars1,chars2);} 方法二:哈希表时空复杂度: O(n) O(n) 我们可以使用哈希表存储每个字符出现的次数，遍历第二个字符串的时候就减去每个字符的个数，当出现个数小于0的情况就返回false,否则就返回true 代码: 1234567891011121314151617181920public boolean hashMethod(String s,String t) { //先判断长度是否相等 if(s.length() != t.length()) { return false; } //遍历字符串存入计数数组中 int[] counts = new int[26]; for(int i = 0; i &lt; s.length(); i ++) { counts[s.charAt(i) - 'a'] ++; } //遍历第二个字符串，当出现小于零就返回false for(int i = 0; i &lt; t.length(); i ++) { counts[t.charAt(i) - 'a'] --; if(counts[t.charAt(i) - 'a'] &lt; 0) { return false; } } //当所有的字符个数都匹配的时候就返回true return true;} 解决Unicode的问题使用map存储: 12345678910111213141516171819202122public boolean mapMethod(String s,String t) { //先判断长度是否相等 if(s.length() != t.length()) { return false; } //创建map存储每个字符出现的次数 Map&lt;Character,Integer&gt; map = new HashMap(); //遍历字符串 for(int i = 0; i &lt; s.length(); i ++) { //增加每个字符的个数 map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0) + 1); } //遍历第二个字符串，减少个数，移除key for(int i = 0; i &lt; t.length(); i ++) { map.put(t.charAt(i),map.getOrDefault(t.charAt(i),0) - 1); //判断个数是否小于等于0 if(map.get(t.charAt(i)) &lt; 0) { return false; } } return true;} 总结这道题目是一道简单题，我们需要掌握关于字符串的常用处理方法，读懂题意其实并不难，其实使用sort的方法看起来代码还是异常的简洁的，但是使用数组计数的方法，时间复杂度会更低一些。","link":"/2023/12/13/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"},{"title":"287.寻找重复数","text":"题目描述给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。 示例 1： 12输入：nums = [1,3,4,2,2]输出：2 示例 2： 12输入：nums = [3,1,3,4,2]输出：3 提示： 1 &lt;= n &lt;= 105 nums.length == n + 1 1 &lt;= nums[i] &lt;= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 进阶： 如何证明 nums 中至少存在一个重复的数字? 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？ 解题思路1.暴力for循环(超时)：时空复杂度: O(n^2) O(1) 我们直接使用两层for循环遍历，从前往后判断当前元素和基准元素是否相等，十分暴力的方法。这个方法没什么好说的了，只能说干就完了。 12345678910public int BrustMethod(int[] nums) { for(int i = 0; i &lt; nums.length; i ++) { for(int j = i + 1; j &lt; nums.length; j ++) { if(nums[i] == nums[j]){ return nums[i]; } } } return 0;} 2.使用哈希表:时空复杂度: O(n) O(n) 遇事不决哈希表，这个方法应该是比较好想到的了吧，用空间换时间。想遍历一次数组把所有元素存入哈希表中，然后再遍历一次，判断是否出现在哈希表中即可，也是十分暴力。其实本人当时也只想到这个方法(手动狗头)。 直接上代码: 1234567891011public int hashMethod(int[] nums) { //存入哈希表 Set&lt;Integer&gt; set = new HashSet(); for(int i = 0; i &lt; nums.length; i ++) { if(set.contains(nums[i])){ return nums[i]; } set.add(nums[i]); } return 0;} 3.二分法:时空复杂度: O(nlogn) O(1) 我们可以根据题目所给条件有n + 1 个整数，数字范围在[1 , n]，我们可以利用小于等于当前数字的元素个数，进行二分查找 这里我使用leetcode案例一中的数据进行分析 nums = [1,3,4,2,2] 当为这个数组的时候 我们可以列出一个小于等于当前元素的表格， 1 2 3 4 1 3 4 5 通过观察我们可以发现一个规律，即如果存在多个重复元素，会导致一种情况. 在这里我假设重复数字为target，则有 [1,target - 1] &lt; nums[target] 和 nums[targe,n] &gt; [target,n] 这就是我们二分单调性的依据，即重复元素会影响数组中元素整体的计数情况 我们只需要二分出来nums[target] &gt; target的那个临界点即可 上代码 1234567891011121314151617181920212223242526272829/**要注意我们要二分的是[1,nums.length - 1]，题目已经告诉我们数字范围在[1,nums.length - 1]而不是二分nums[mid],这里要清楚**/public int binSearch(int[] nums) { //定义两个指针 int l = 1, r = nums.length - 1; //当l &lt; r的时候进行二分 while(l &lt; r) { //中点为 (l + r) / 2,这里用的位运算，右移一位代表除以2 int mid = l + r &gt;&gt; 1; //定义一个统计小于等于mid的的变量 int cnt = 0; //统计小于等于mid的元素个数 for(int i = 0; i &lt; nums.length; i ++) { if(nums[i] &lt;= mid) { cnt ++; } } //如果cnt &lt;= mid则继续二分右边的 if(cnt &lt;= mid) { l = mid + 1; } else { //否则继续二分左边 r = mid; } } return r;} 4.快慢指针法:时空复杂度: O(n) O(1) 这种方法属实牛逼(手动狗头)，具体的实现思路其实和LeetCode上142题&lt;&lt;环形链表&gt;&gt;非常相似，具体使用的是Floyd判圈算法。 具体思路是定义一个慢指针，一个快指针，让快指针一次移动两个节点，慢指针一次移动一个节点，当链表中存在环的时候，快慢指针会在环中相遇，因为快指针相对于慢指针每次移动一个节点，相当于在追赶慢指针，只要存在环，就一定能追上。 这里贴出来链接，需要了解为什么有环一定能追上快指针的小伙伴可以自行查看。Leetcode 142.环形链表 1234567891011121314151617181920public int dualPointMethod(int[] nums) { //直接定义快慢指针，这里使用int变量模拟指针 int slow = nums[0]; int fast = nums[0]; //循环遍历数组，类似遍历链表，找到快慢指针的交点 do{ slow = nums[slow]; fast = nums[nums[fast]]; }while(slow != fast); //当找到交点的时候，利用从头节点开始的指针和交点开始的指针来查找数组中的初始交点 slow = nums[0]; int p = fast; while(slow != p) { slow = nums[slow]; p = nums[p]; } return slow;} 总结这道题目有多种解题方法，还是非常考验经验积累和思路的，不然像作者一样只会使用哈希表和暴力了，第四种方法快慢指针，使用的Floyd判圈算法真的十分巧妙，将链表中的判断是否有环的思路运用到数组中去，也能实现同样的效果，只能说是异曲同工之妙了！ 当没有什么思路的时候，不妨将各种数据结构都想一遍，看能不能找到合适的数据结构解题！","link":"/2023/12/10/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"},{"title":"438.找到字符串中所有字母异位词","text":"题目描述给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 示例 2: 123456输入: s = &quot;abab&quot;, p = &quot;ab&quot;输出: [0,1,2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。 提示: 1 &lt;= s.length, p.length &lt;= 3 * 104 s 和 p 仅包含小写字母 题解思路方法一：哈希表时空复杂度: O((s.len - p.len) * p.len) 这里的两个字符串长度决定了循环的次数; 空间复杂度为O(26)即26个英文字母的大小 我们可以利用哈希表存储p字符串的所有字母出现的个数，然后循环遍历s字符串每个字母，然后截取区间内的字符出现的次数，和哈希表存储的个数进行比较，当相等的时候就可以得到起始索引，当然，这种方法应该算是比较暴力的方法了。 上代码： 1234567891011121314151617181920212223242526public List&lt;Integer&gt; hashMethod(String s,String p) { if(s.length() &lt; p.length()) { return new ArrayList&lt;Integer&gt;(); } //得到p的计数数组 int[] countp = new int[26]; //遍历p得到计数 for(int i = 0; i &lt; p.length(); i ++) { countp[p.charAt(i) - 'a'] ++; } //创建结果List List&lt;Integer&gt; list = new ArrayList(); //遍历s字符串 for(int i = 0; i &lt;= s.length() - p.length(); i ++) { //获取计数数组 int[] counts = new int[26]; for(int j = i; j &lt; i + p.length(); j ++) { counts[s.charAt(j) - 'a'] ++; } //当counts和countp相等的时候就加入list中 if(Arrays.equals(counts,countp)) { list.add(i); } } return list;} 方法二：滑动窗口时空复杂度: O(s.len * 26) 这里的时间复杂度取决于s长度的大小，空间复杂度为O(26)只需要维护一个26字母的字符集 我们利用两个字符串的每个字符个个数作为滑动窗口的判断条件,定义两个指针，一个指向左边，一个指向右边，两个指针中间维护的窗口中的字符个数应该和p字符串的中字符种类和个数相同，当右指针往右移动的时候判断是否满足条件，当满足条件就记录起始点。 123456789101112131415161718192021222324252627282930public List&lt;Integer&gt; slideMethod(String s,String p) { //首先判断s和t的大小 if(s.length() &lt; p.length()) { return new ArrayList&lt;Integer&gt;(); } //创建结果集合 List&lt;Integer&gt; res = new ArrayList(); //创建p字符串的计数数组 int[] countp = new int[26]; for(int i = 0; i &lt; p.length(); i ++) { countp[p.charAt(i) - 'a'] ++; } //创建左右指针，维护滑动窗口 int left = 0; int[] counts = new int[26]; for(int right = 0; right &lt; s.length(); right ++) { //将right指针指向的位置的字符加入count中 counts[s.charAt(right) - 'a'] ++; //当区间长度大于p的长度就让left指针右移 if(right - left + 1 &gt; p.length()) { counts[s.charAt(left) - 'a'] --; left ++; } //判断当前区间是否符合条件 if(Arrays.equals(countp,counts)) { res.add(left); } } return res;} 方法三：滑动窗口(优化版)时空复杂度: O(n) O(26) 根据上一个普通的滑动窗口方法，我们可以做出改进，取消使用两个count计数数组，而是改为使用diff变量记录两个数组中每个数字出现次数的差异。当diff = 0的时候代表滑动窗口内的元素是异位数。下面我们用代码来实现这个思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public List&lt;Integer&gt; slideOpt(String s,String p) { //先判断两个字符串的大小 if(s.length() &lt; p.length()) return new ArrayList(); //创建一个count数组用于记录每个元素出现的次数 int[] count = new int[26]; //创建diff变量 int diff = 0; for(int i = 0; i &lt; p.length(); i ++) { count[s.charAt(i) - 'a'] ++; count[p.charAt(i) - 'a'] --; } //判断出现元素的差异个数 for(int i = 0; i &lt; 26; i ++) { if(count[i] != 0) { diff ++; } } //创建结果集合 List&lt;Integer&gt; res = new ArrayList(); if(diff == 0) { res.add(0); } //这里是滑动窗口移动的距离，从0一直移动到 s.len - p.len - 1 for(int i = 0; i &lt; s.length() - p.length(); i ++) { //向右滑动判断diff的改变 if(count[s.charAt(i) - 'a'] == 1) { //等于1代表没移动之前窗口中比p中多一个元素，移动后可以抹去一个差异 diff --; } else if(count[s.charAt(i) - 'a'] == 0) { //等于0的话，移动后就多了一个差异 diff ++; } //减去左边移去的元素 count[s.charAt(i) - 'a'] --; //判断右端点diff后的改变 if(count[s.charAt(i + p.length()) - 'a'] == -1) { //这里为-1代表没移动之前比p中少一个元素，移动后可以抹去差异 diff --; } else if(count[s.charAt(i + p.length()) - 'a'] == 0) { diff ++; } //加入右边移动的元素 count[s.charAt(i + p.length()) - 'a'] ++; //判断diff是不是为0 if(diff == 0) { res.add(i + 1); //注意：这里是加入移动后的位置即i+1 } } return res;} 总结这题使用基础暴力方法，选择对了数据结构也是可以做出来的，就是时间复杂度可能比较高，但还是可以通过leetcode的数据测试，想要优化的话，我们就需要使用滑动窗口算法，这种方法是用于在一个字符串中查找子串，或者判断异位词等多种情况下大幅度减小时间复杂度的一种方法。需要我们多积累滑动窗口的应用场景！","link":"/2023/12/16/438.%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"},{"title":"350.两个数组的交集","text":"题目描述给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 题解方法一：双指针时空复杂度: O(nlogn) O(1) 我们可以通过排序数组，得到两个排好序的数组，定义两个指针p1,p2分别指向两个数组，当两个指针没有到达数组末尾的时候我们就让指向的数字小的那个指针向后移动，当遇到两个指针元素相等的情况，就将元素加入结果集中。 代码: 12345678910111213141516171819202122232425262728293031323334public int[] dualPoint(int[] nums1,int[] nums2) { //先判断特殊情况 if(nums1 == null || nums2 == null) return new int[0]; //对数组进行排序 Arrays.sort(nums1); Arrays.sort(nums2); //定义两个指针 int p1 = 0,p2 = 0; List&lt;Integer&gt; list = new ArrayList(); while(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length) { //如果p1指向的元素小于p2就向后移动 if(nums1[p1] &lt; nums2[p2]) { p1 ++; } else if(nums1[p1] &gt; nums2[p2]) { p2 ++; } //判断元素是否相等 if(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length &amp;&amp; nums1[p1] == nums2[p2]) { list.add(nums1[p1]); p1 ++; p2 ++; } } //转换成数组 int index = 0; int[] res = new int[list.size()]; for(int num : list) { res[index ++] = num; } return res;} 方法二：哈希表时空复杂度: O(n) O(n) 当两个数组中都存在相同的元素，我们取出现次数较小的那一个计数，所以我们可以将长度更大的数组进行计数，然后递减遍历数组中的数字次数，当出现次数大于0的时候我们就将当前数字加入结果集中，否则代表当前遍历数组中出现次数为更大的那个。就不需要加入结果集。 代码: 123456789101112131415161718192021222324252627282930public int[] hashMethod(int[] nums1,int[] nums2) { //判断数组大小 //使用递归交换两个数组 if(nums1.length &lt; nums2.length) { return hashMethod(nums2,nums1); } //创建计数数组 int[] count = new int[1005]; //遍历较长的数组，并计数 for(int num : nums1) { count[num] ++; } List&lt;Integer&gt; list = new ArrayList(); //遍历长度较小的数组 for(int num : nums2) { if(count[num] &gt; 0) { list.add(num); } count[num] --; } //转换成数组 int index = 0; int[] res = new int[list.size()]; for(int num : list) { res[index ++] = num; } return res;} 总结这道题目主要考察了对于哈希表和双指针的应用，需要结合题目给出的数据判断使用什么方法解答，解题过程中要考虑时间复杂度，双指针使用过程中我们要考虑对于指针移动条件的判定，这道题目是对元素大小进行判断，让小的那一方指针进行移动。","link":"/2023/12/15/350.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"title":"49.字母异位词分组","text":"题目描述给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 示例 1: 12输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]] 示例 2: 12输入: strs = [&quot;&quot;]输出: [[&quot;&quot;]] 示例 3: 12输入: strs = [&quot;a&quot;]输出: [[&quot;a&quot;]] 提示： 1 &lt;= strs.length &lt;= 104 0 &lt;= strs[i].length &lt;= 100 strs[i] 仅包含小写字母 题解方法一：排序时空复杂度: O(nklogk) O(nk) 其中的n是字符串数组长度，k是字符串的最大长度 这道题目跟上一题十分相似啊，我们可以在遍历字符串数组的时候对每个字符串进行排序，这样得到的字符串一定是相等的。然后将相同的字符串加入到List中即可。 12345678910111213141516171819public List&lt;List&lt;String&gt;&gt; sortMethod(String[] strs) { //创建结果集 Map&lt;String,List&lt;String&gt;&gt; map = new HashMap(); //遍历字符串数组 for(String str : strs) { //直接sort排序 char[] chs = str.toCharArray(); Arrays.sort(chs); String s = new String(chs); //判断在map中是否出现 List&lt;String&gt; list = map.getOrDefault(s,new ArrayList&lt;String&gt;()); //将当前的str存入list中 list.add(str); //存入map中 map.put(s,list); } //这里使用new ArrayList(Collection&lt;E&gt; collection)直接创建一个List,因为map.values()返回的是一个Collection return new ArrayList(map.values());} 方法二：哈希表时空复杂度: O(n(k + 26)) O(n(k + 26)) 其中的n是字符串数组长度，k是字符串的最大长度 我们可以直接遍历每个字符串，然后将字符串中的字符出现的个数拼接后当作key存入map中，这样我们就可以根据固定的key来存储源字符串了 12345678910111213141516171819202122232425262728public List&lt;List&lt;String&gt;&gt; hashMethod(String[] strs) { //创建结果集 Map&lt;String,List&lt;String&gt;&gt; map = new HashMap(); //遍历字符数组 for(String str : strs) { //创建计数数组 int[] counts = new int[26]; //遍历字符串计数 char[] chs = str.toCharArray(); for(int i = 0; i &lt; chs.length; i ++) { counts[chs[i] - 'a'] ++; } //创建StringBuffer StringBuffer sb = new StringBuffer(); for(int i = 0; i &lt; 26; i ++) { //拼接key sb.append((char)('a' + i)); sb.append(counts[i]); } //生成key String key = sb.toString(); //存入map List&lt;String&gt; list = map.getOrDefault(key,new ArrayList()); list.add(str); map.put(key,list); } return new ArrayList(map.values());} 总结其实这道题目的两种方法，底层思想都是类似的，利用哈希表来存储key，然后将不同的异位词存入哈希表中对应的List中，最后直接将map对应的values转换成List返回即可。","link":"/2023/12/13/49.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"},{"title":"面试题-链表相交","text":"题目：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交编辑 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： 编辑 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 思路/代码这道题目相对来说是比较简单的了，但是本人还是没有想出来第二种方法，只能说双指针YYDS，而且还需要对两个指针遍历的数量关系有一定的了解 这题就是利用了链表A和B的长度数量关系和指针遍历的特性进行解题的 首先来讲一讲方法一: 哈希集合对大家来说应该不会陌生，Set集合中有一个方法contains()可以获取集合中是否存在指定的元素，我们可以先遍历链表A，将链表中的所有元素存入Set集合中，由于题目告诉我们了，相交链表没有环，所以我们可以使用P指针直接遍历B链表，然后对B链表中每个元素使用contains()方法判断是否存在于Set集合中，存在就直接返回，当P指针为NULL的时候代表A和B链表不相交 具体代码: 12345678910111213141516171819public ListNode setMethod(ListNode headA,ListNode headB) { Set&lt;ListNode&gt; set = new HashSet(); //将A链表元素存入集合中 while(headA != null) { set.add(headA); headA = headA.next; } //遍历B链表判断是否存在于集合中 while(headB != null) { if(set.contains(headB)){ return headB; } headB = headB.next; } //没有找到交点 return null;} 接下来就是十分优雅的双指针解法了、看到这个解法真的是秀了我一脸 具体思路就是定义两个指针P1和P2，让P1和P2分别同时向后移动，链表会有两种情况 两个链表有交点 我们可以假设链表A长度为m，链表B长度为n，链表A不相交的长度为a,链表B不相交长度为b,两个链表相交部分长度为c 当$a = b$的时候，我们的P1和P2指针应该是可以同时移动到一个相等节点的，这个时候直接返回P1指针指向的元素即可 当$a \\neq b$的时候 P1指针应该移动a + c + b才能到达相交的位置，P2指针应该移动b + c + a才能到达相交的位置 由于 a + c + b = b + c + a 所以当P1指针先到达NULL的时候让其指向B链表，当P2指针到达NULL让其指向A链表，并且继续向后移动，直到$P1 = P2$就可以返回P1 两个链表无交点 当$a \\neq b$时候，P1移动m+n，P2移动n+m的时候相等，而且都等于NULL 当$a = b$的时候，P1移动m，P2移动n的时候相等，而且都为NULL 12345678910111213141516public ListNode setMethod(ListNode headA,ListNode headB) { //如果A或者B链表有一个为NULL就不可能有交点 if(headA == null || headB == null) { return null; } //定义两个指针 ListNode p1 = headA; ListNode p2 = headB; while(p1 != p2) { p1 = p1 == null ? headB : p1.next; p2 = p2 == null ? headA : p2.next; } //不管如何都返回p1，因为最后不是相交节点就是NULL return p1;} 总结这道题目其实更多考察的是思维上的模式，代码并不难，我们要学会对问题进行抽象，并且分析问题中的关键对象和数量关系，只有看懂了题目才能有思路，有了思路，解题就能更加得心应手！ 共勉！","link":"/2023/12/09/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.07.%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"}],"tags":[],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}